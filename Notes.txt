1) Collapse a binary tree into a doubly linked list with the root of the tree in the middle and the head of the linked list as the left most element in the left subtree.

2) Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.
   - 2 / 2 = 1, 2 / 3 = 0
   - 4 / 1 = 4 20 / 5 = 4
   - subtract full amout of divisor till and count unber of times that you can

3) Given the head of a linked list, remove the nth node from the end of the list and return its head.
   - Start a counter and track the prevous node. 
   - Once you reach the Nth node change the prevouses next to the one after the nth

4) Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
   - Loop through array skip first new number
   - Delete elements that are the same

5) Create a second array that is one index larger than the original. Then loop through original array and set the new array by new_array[left] = min(new_array[left], right - left). The Loop through while end is less than len(old_array). Use 2 pointers and shift start to equal end every step.